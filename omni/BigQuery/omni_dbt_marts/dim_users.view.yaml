# Reference this view as omni_dbt_marts__dim_users
schema_label: ""
#This description was pulled from dbt.
description: |
  Dimension table for users. Extracted from staging events data.

schema: omni_dbt_marts
table_name: dim_users

dimensions:
  first_event_time:
    #This description was pulled from dbt.
    description: Timestamp of the user's first interaction with the platform

  first_event_date:
    #This description was pulled from dbt.
    description: Date of the user's first interaction with the platform

  last_event_time:
    #This description was pulled from dbt.
    description: Timestamp of the user's most recent interaction with the platform

  last_event_date:
    #This description was pulled from dbt.
    description: Date of the user's most recent interaction with the platform

  session_count:
    #This description was pulled from dbt.
    description: Total number of sessions for the user, sourced from fct_sessions
      (sessions split at 1-hour inactivity gaps). 0 if no sessions exist.

  event_count:
    #This description was pulled from dbt.
    description: Total number of events generated by the user

  total_revenue:
    #This description was pulled from dbt.
    description: Total revenue generated by the user

  purchase_count:
    #This description was pulled from dbt.
    description: Total number of purchase events generated by the user

  first_purchase_date:
    #This description was pulled from dbt.
    description: Date of the user's first purchase event

  last_purchase_date:
    #This description was pulled from dbt.
    description: Date of the user's most recent purchase event

  avg_order_value:
    #This description was pulled from dbt.
    description: Average order value for the user

  customer_lifespan_days:
    #This description was pulled from dbt.
    description: Number of days between the user's first and last purchase. Minimum
      1 for any user with at least one purchase. NULL for non-purchasers.

  days_since_last_activity:
    #This description was pulled from dbt.
    description: Number of days between the most recent event_date in the dataset
      (reference date) and this user's last event. Reference date is
      max(event_date) from fct_events.

  days_since_last_purchase:
    #This description was pulled from dbt.
    description: Number of days between the most recent event_date in the dataset
      (reference date) and this user's last purchase. NULL for non-purchasers.
      Reference date is max(event_date) from fct_events.

  customer_ltv:
    #This description was pulled from dbt.
    description: Customer lifetime value. Same as total_revenue; just semantic clarity.

  activity_status:
    #This description was pulled from dbt.
    description: User activity status based on purchase recency and browsing
      activity. Churned requires both purchase and activity to have lapsed
      beyond churn_threshold_days.
    all_values: [ active, declining, at_risk, churned, prospect ]

  is_churned:
    #This description was pulled from dbt.
    description: Flag for churned users (1 for churned, 0 otherwise). Requires both
      days_since_last_purchase and days_since_last_activity to exceed
      churn_threshold_days.

  has_purchase_history:
    #This description was pulled from dbt.
    description: Boolean flag indicating whether the user has made at least one purchase.

  data_quality_flag:
    #This description was pulled from dbt.
    description: Data quality indicator. NULL when no issues detected.
      'missing_sessions' if session_count is 0. 'anomalous_session_ratio' if
      events-per-session exceeds session_outlier_ratio var.
    sample_values: [ missing_sessions, anomalous_session_ratio ]

  user_id:
    format: ID
    #This description was pulled from dbt.
    description: Unique identifier for the user

measures:
  count:
    aggregate_type: count

#The info below was pulled from your dbt repository and is read-only.
dbt:
  name: dim_users
  target_schema: estore
  description: |
    Dimension table for users. Extracted from staging events data.
  config:
    schema: marts
    materialized: incremental
  code: |-
    {{ config(
        materialized = 'incremental',
        unique_key = 'user_id',
        cluster_by = ['user_id'],
        incremental_strategy = 'merge',
        on_schema_change = 'sync_all_columns'
    ) }}

    with

    source as (

        select * from {{ ref('fct_events') }}

    ),

    max_date as (

        select max(event_date) as max_date
        from source

    ),

    cleaned_sessions as (

        select
            user_id,
            count(*) as session_count
        from {{ ref('fct_sessions') }}
        group by user_id

    ),

    transformed as (

        select

            user_id,

            min(event_time) as first_event_time,
            min(event_date) as first_event_date,
            max(event_time) as last_event_time,
            max(event_date) as last_event_date,
            count(*) as event_count,

            round(sum(
                case
                    when is_purchase = 1
                        then revenue
                end
            ), 2) as total_revenue,

            count(
                case
                    when is_purchase = 1
                        then 1
                end
            ) as purchase_count,

            min(
                case
                    when is_purchase = 1
                        then event_date
                end
            ) as first_purchase_date,

            max(
                case
                    when is_purchase = 1
                        then event_date
                end
            ) as last_purchase_date,

            round(avg(
                case
                    when is_purchase = 1
                        then revenue
                end
            ), 2) as avg_order_value,

            case
                when
                    count(case when is_purchase = 1 then 1 end) > 0
                    then greatest(
                        date_diff(
                            max(case when is_purchase = 1 then event_date end),
                            min(case when is_purchase = 1 then event_date end),
                            day
                        ),
                        1
                    )
            end as customer_lifespan_days,

            date_diff(
                (select max_date.max_date from max_date),
                max(event_date),
                day
            ) as days_since_last_activity,

            date_diff(
                (select max_date.max_date from max_date),
                max(case when is_purchase = 1 then event_date end),
                day
            ) as days_since_last_purchase

        from source

        group by user_id

    ),

    churn_classified as (

        select
            transformed.user_id,
            transformed.first_event_time,
            transformed.first_event_date,
            transformed.last_event_time,
            transformed.last_event_date,
            coalesce(cleaned_sessions.session_count, 0) as session_count,
            transformed.event_count,
            transformed.total_revenue,
            transformed.purchase_count,
            transformed.first_purchase_date,
            transformed.last_purchase_date,
            transformed.avg_order_value,
            transformed.customer_lifespan_days,
            transformed.days_since_last_activity,
            transformed.days_since_last_purchase,

            transformed.total_revenue as customer_ltv,

            case
                when
                    transformed.purchase_count > 0
                    and transformed.days_since_last_purchase
                    > {{ var('churn_threshold_days') }}
                    and transformed.days_since_last_activity
                    > {{ var('churn_threshold_days') }}
                    then 'churned'
                when
                    transformed.purchase_count > 0
                    and transformed.days_since_last_purchase
                    > {{ var('at_risk_threshold_days') }}
                    then 'at_risk'
                when
                    transformed.purchase_count > 0
                    and transformed.days_since_last_purchase
                    > {{ var('declining_threshold_days') }}
                    then 'declining'
                when transformed.purchase_count > 0 then 'active'
                else 'prospect'
            end as activity_status,

            case
                when
                    transformed.purchase_count > 0
                    and transformed.days_since_last_purchase
                    > {{ var('churn_threshold_days') }}
                    and transformed.days_since_last_activity
                    > {{ var('churn_threshold_days') }}
                    then 1
                else 0
            end as is_churned,

            transformed.purchase_count > 0 as has_purchase_history,

            case
                when coalesce(cleaned_sessions.session_count, 0) = 0
                    then 'missing_sessions'
                when
                    cleaned_sessions.session_count > 0
                    and safe_divide(
                        transformed.event_count,
                        cleaned_sessions.session_count
                    ) > {{ var('session_outlier_ratio') }}
                    then 'anomalous_session_ratio'
            end as data_quality_flag

        from transformed

        left join cleaned_sessions
            on transformed.user_id = cleaned_sessions.user_id

    ),

    final as (

        select

            user_id,
            first_event_time,
            first_event_date,
            last_event_time,
            last_event_date,
            session_count,
            event_count,
            total_revenue,
            purchase_count,
            first_purchase_date,
            last_purchase_date,
            avg_order_value,
            customer_lifespan_days,
            days_since_last_activity,
            days_since_last_purchase,
            customer_ltv,
            activity_status,
            is_churned,
            has_purchase_history,
            data_quality_flag

        from churn_classified

    )

    select * from final
  referenced_by: [ dim_user_rfm, metrics_churn, snap_user_status, metrics_rfm_segments ]
