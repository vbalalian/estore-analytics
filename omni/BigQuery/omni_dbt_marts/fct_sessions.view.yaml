# Reference this view as omni_dbt_marts__fct_sessions
schema_label: ""
#This description was pulled from dbt.
description: |
  Session fact table that applies a 1-hour inactivity timeout to split sessions spanning unreasonably long periods. 2.16% of sessions in the raw data span up to 6 months due to session IDs being reused without an inactivity timeout. This model detects gaps >3600 seconds between consecutive events within a session and assigns new session IDs at each timeout boundary.

schema: omni_dbt_marts
table_name: fct_sessions

dimensions:
  session_id:
    format: ID
    #This description was pulled from dbt.
    description: |
      Cleaned session identifier. Original session ID if no timeout occurred, or original_id + '_timeout_' + occurrence_number for split sessions.

  session_start_time:
    #This description was pulled from dbt.
    description: Timestamp of the first event in the session

  session_start_date:
    #This description was pulled from dbt.
    description: Date of the first event in the session, used for partitioning

  user_id:
    format: ID
    #This description was pulled from dbt.
    description: Identifier for the user who initiated the session

  session_end_time:
    #This description was pulled from dbt.
    description: Timestamp of the last event in the session

  event_count:
    #This description was pulled from dbt.
    description: Total number of events in the session

  unique_product_count:
    #This description was pulled from dbt.
    description: Number of unique products interacted with during the session

  cart_additions:
    #This description was pulled from dbt.
    description: Total number of add-to-cart events during the session

  purchase_count:
    #This description was pulled from dbt.
    description: Total number of purchase events during the session

  view_count:
    #This description was pulled from dbt.
    description: Total number of view events during the session

  total_revenue:
    #This description was pulled from dbt.
    description: Total revenue generated from purchase events during the session

  session_length:
    #This description was pulled from dbt.
    description: Duration of the session in seconds (end - start)

  reached_view:
    #This description was pulled from dbt.
    description: Indicator (1/0) if the session included at least one view event

  reached_cart:
    #This description was pulled from dbt.
    description: Indicator (1/0) if the session included at least one add-to-cart event

  reached_purchase:
    #This description was pulled from dbt.
    description: Indicator (1/0) if the session included at least one purchase event

  funnel_stage:
    #This description was pulled from dbt.
    description: Furthest stage reached in the purchase funnel during the session
    all_values: [ purchase, cart, view, no_activity ]

measures:
  count:
    aggregate_type: count

#The info below was pulled from your dbt repository and is read-only.
dbt:
  name: fct_sessions
  target_schema: estore
  description: |
    Session fact table that applies a 1-hour inactivity timeout to split sessions spanning unreasonably long periods. 2.16% of sessions in the raw data span up to 6 months due to session IDs being reused without an inactivity timeout. This model detects gaps >3600 seconds between consecutive events within a session and assigns new session IDs at each timeout boundary.
  config:
    schema: marts
    materialized: table
  code: |-
    {{ config(
        materialized = 'table',
        partition_by = {
            "field": "session_start_date",
            "data_type": "date",
            "granularity": "day"
        },
        cluster_by = ['user_id', 'session_start_date']
    ) }}

    with

    events as (
        select
            event_time,
            user_session,
            user_id,
            product_id,
            is_cart_add,
            is_purchase,
            is_view,
            revenue
        from {{ ref('fct_events') }}
    ),

    events_with_gaps as (
        select
            event_time,
            user_session,
            user_id,
            product_id,
            is_cart_add,
            is_purchase,
            is_view,
            revenue,
            datetime_diff(
                event_time,
                lag(event_time) over (
                    partition by user_session
                    order by event_time
                ),
                second
            ) as seconds_since_prev_event
        from events
    ),

    timeout_flags as (
        select
            event_time,
            user_session,
            user_id,
            product_id,
            is_cart_add,
            is_purchase,
            is_view,
            revenue,
            case
                when
                    seconds_since_prev_event
                    > {{ var('session_timeout_seconds') }}
                    then 1
                else 0
            end as is_timeout
        from events_with_gaps
    ),

    sub_sessions as (
        select
            event_time,
            user_session,
            user_id,
            product_id,
            is_cart_add,
            is_purchase,
            is_view,
            revenue,
            sum(is_timeout) over (
                partition by user_session
                order by event_time
                rows between unbounded preceding and current row
            ) as timeout_occurrence
        from timeout_flags
    ),

    events_with_cleaned_id as (
        select
            event_time,
            user_id,
            product_id,
            is_cart_add,
            is_purchase,
            is_view,
            revenue,
            case
                when timeout_occurrence = 0 then user_session
                else concat(
                    user_session,
                    '_timeout_',
                    cast(timeout_occurrence as string)
                )
            end as cleaned_session_id
        from sub_sessions
    ),

    cleaned_sessions as (
        select
            cleaned_session_id as session_id,
            min(event_time) as session_start_time,
            date(min(event_time)) as session_start_date,
            max(user_id) as user_id,
            max(event_time) as session_end_time,
            count(*) as event_count,
            count(distinct product_id) as unique_product_count,
            sum(is_cart_add) as cart_additions,
            sum(is_purchase) as purchase_count,
            sum(is_view) as view_count,
            sum(revenue) as total_revenue,
            datetime_diff(max(event_time), min(event_time), second)
                as session_length,

            case when sum(is_view) > 0 then 1 else 0 end as reached_view,
            case when sum(is_cart_add) > 0 then 1 else 0 end as reached_cart,
            case when sum(is_purchase) > 0 then 1 else 0 end as reached_purchase,

            case
                when sum(is_purchase) > 0 then 'purchase'
                when sum(is_cart_add) > 0 then 'cart'
                when sum(is_view) > 0 then 'view'
                else 'no_activity'
            end as funnel_stage

        from events_with_cleaned_id
        group by cleaned_session_id
    )

    select * from cleaned_sessions
  referenced_by: [ dim_users, metrics_conversion_rates ]
